// Leetcode problem # 128
/*
Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.

You must write an algorithm that runs in O(n) time.

Example 1:
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.

Example 2:
Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9

Constraints:
    0 <= nums.length <= 105
    -109 <= nums[i] <= 109
*/

// 1. Brute Force

var longestConsecutiveBruteForce = function (nums) {
  let res = 0;
  const store = new Set(nums);

  for (let num of nums) {
      let streak = 0, curr = num;
      while (store.has(curr)) {
          streak++;
          curr++;
      }
      res = Math.max(res, streak);
  }
  return res;
}

/* Note this answer would be unacceptable due to the problem asking for O(n) time.
We create a hashset out of the given array.
We check each number in the array against the hashset.
If the number exists in the hash set, then we see if the +1 (next conse #) is also in the hashset. If it is, we check the next and also iterate the streak counter.

The problem lies in that we are checking every single number of the given array and then "re-doing" work when checking for consecutive numbers.
Ex - [100,4,200,1,3,2]
From outside looking in, we know that the longest streak will be 4 because 1-2-3-4 are in the array but because the information is not considered, our code does additional work from not making use of contextual information (additional conditions). 

This leads us to a more optimized solution, sorting.
*/

// Sorting 
var longestConsecutiveSort = function (nums) {
  if (nums.length === 0) {
      return 0;
  }

  nums.sort((a, b) => a - b);
  
  let res = 0, curr = nums[0], streak = 0, i = 0;

  while (i < nums.length) {
      if (curr !== nums[i]) {
          curr = nums[i];
          streak = 0;
      }
      while (i < nums.length && nums[i] === curr) {
          i++;
      }
      streak++;
      curr++;
      res = Math.max(res, streak);
  }
  return res;
}

/* Here we added an easy early return (don't try to run code if the array is empty) that could've been included in the brute force.



Time - O(nlogn)
Space - O(1) 

*/

// 3. hash Set

var longestConsecutiveHashSet = function(nums) {
  const numSet = new Set(nums);
  let longest = 0;

  for (let num of nums) {
      if (!numSet.has(num - 1)) {
          let length = 1;
          while (numSet.has(num + length)) {
              length++;
          }
          longest = Math.max(longest, length);
      }
  }
  return longest;
}

/* Better than sorting but takes up additional space
Time - O(n)
Space - O(n)

*/


// 4. Hashmap answer

var longestConsecutive = function(nums) {
  const numMap = new Map();
  let longest = 0;

  for (let num of nums) {
      if (!numMap.has(num)) {
          numMap.set(num, (numMap.get(num - 1) || 0) + (numMap.get(num + 1) || 0) + 1);
          numMap.set(num - (numMap.get(num - 1) || 0), numMap.get(num));
          numMap.set(num + (numMap.get(num + 1) || 0), numMap.get(num));
          longest = Math.max(longest, numMap.get(num));
      }
  }
  return longest;
};

/* Similar to the hashset answer without the hashset rulesets.

*/